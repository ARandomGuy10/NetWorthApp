-- =============================================
-- NetWorthApp Database Schema - Final Version
-- amount > 0 enforced in balance_entries for clarity
-- =============================================

-- 0. Required Extensions
CREATE EXTENSION IF NOT EXISTS "pgcrypto";  -- Enables gen_random_uuid()

-- =============================================


-- 1. Custom Types
CREATE TYPE public.theme AS ENUM (
  'LIGHT', 
  'DARK', 
  'SYSTEM', 
  'MODERN_FINANCE', 
  'WARM_LUXURY', 
  'NEO_BANKING', 
  'DARK_MODE_FOCUSED', 
  'EARTHY_CALM'
);
CREATE TYPE public.account_type AS ENUM ('asset', 'liability');
CREATE TYPE public.currency_code AS ENUM (
    'AUD', 'BGN', 'BRL', 'CAD', 'CHF', 'CNY', 'CZK', 'DKK', 
    'EUR', 'GBP', 'HKD', 'HUF', 'IDR', 'ILS', 'INR', 'ISK', 
    'JPY', 'KRW', 'MXN', 'MYR', 'NOK', 'NZD', 'PHP', 'PLN', 
    'RON', 'SEK', 'SGD', 'THB', 'TRY', 'USD', 'ZAR'
);
-- =============================================

-- 2. Auth Helper Function â€“ Extract user ID from Clerk JWT
CREATE OR REPLACE FUNCTION get_user_id()
RETURNS TEXT AS $$
  SELECT nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::TEXT;
$$ LANGUAGE sql STABLE;

-- =============================================

-- 3. Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
  id TEXT PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  email TEXT UNIQUE,
  preferred_currency public.currency_code NOT NULL DEFAULT 'EUR',
  timezone VARCHAR(50) DEFAULT 'UTC',
  date_format VARCHAR(20) DEFAULT 'YYYY-MM-DD',
  avatar_url TEXT,
  last_sign_in_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  theme public.theme NOT NULL DEFAULT 'DARK'
);

-- =============================================

-- 4. Accounts Table
CREATE TABLE IF NOT EXISTS public.accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL CHECK (length(trim(name)) > 0),
  type public.account_type NOT NULL,
  currency public.currency_code NOT NULL DEFAULT 'EUR',
  category TEXT NOT NULL,
  institution TEXT DEFAULT '',
  include_in_net_worth BOOLEAN DEFAULT TRUE,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- =============================================

-- 5. Balance Entries Table (amount > 0)
CREATE TABLE IF NOT EXISTS public.balance_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID REFERENCES public.accounts(id) ON DELETE CASCADE NOT NULL,
  amount DECIMAL(15,2) NOT NULL CHECK (amount > 0),
  date DATE NOT NULL,
  notes TEXT DEFAULT '',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE (account_id, date)
);

-- =============================================

-- 7. Enable Row-Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.balance_entries ENABLE ROW LEVEL SECURITY;

-- =============================================

-- 8. RLS Policies

-- Profiles
CREATE POLICY "Users can view their own profile" 
  ON public.profiles FOR SELECT TO authenticated
  USING (id = get_user_id());

CREATE POLICY "Users can insert their own profile" 
  ON public.profiles FOR INSERT TO authenticated
  WITH CHECK (id = get_user_id());

CREATE POLICY "Users can update their own profile" 
  ON public.profiles FOR UPDATE TO authenticated
  USING (id = get_user_id());

CREATE POLICY "Users can delete their own profile" 
  ON public.profiles FOR DELETE TO authenticated
  USING (id = get_user_id());

-- Accounts
CREATE POLICY "Users can read their own accounts"
  ON public.accounts FOR SELECT TO authenticated
  USING (user_id = get_user_id());

CREATE POLICY "Users can insert their own accounts"
  ON public.accounts FOR INSERT TO authenticated
  WITH CHECK (user_id = get_user_id());

CREATE POLICY "Users can update their own accounts"
  ON public.accounts FOR UPDATE TO authenticated
  USING (user_id = get_user_id());

CREATE POLICY "Users can delete their own accounts"
  ON public.accounts FOR DELETE TO authenticated
  USING (user_id = get_user_id());

-- Balance Entries
CREATE POLICY "Users can read own balance entries"
  ON public.balance_entries FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can insert own balance entries"
  ON public.balance_entries FOR INSERT TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can update own balance entries"
  ON public.balance_entries FOR UPDATE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can delete own balance entries"
  ON public.balance_entries FOR DELETE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

-- =============================================

-- 9. Timestamp Trigger Function
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================

-- 10. Triggers to update updated_at on update
CREATE TRIGGER trg_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER trg_accounts_updated_at
  BEFORE UPDATE ON public.accounts
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER trg_balance_entries_updated_at
  BEFORE UPDATE ON public.balance_entries
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- =============================================

-- 11.  Improved accounts with balances function
-- Function to get accounts balances for the current authenticated user
CREATE OR REPLACE FUNCTION public.get_accounts_with_balances(
)
RETURNS TABLE(
    account_id uuid,
    account_name text,
    account_type public.account_type,
    category text,
    institution text,
    currency public.currency_code,
    latest_balance decimal,
    latest_balance_date date
) AS $$
BEGIN
    RETURN QUERY
    WITH ranked_balances AS (
        SELECT 
            a.id AS account_id,
            a.name AS account_name,
            a.type AS account_type,
            a.category,
            a.institution,
            a.currency,
            be.amount AS latest_balance,
            be.date AS latest_balance_date,
            ROW_NUMBER() OVER (
                PARTITION BY a.id 
                ORDER BY be.date DESC NULLS LAST
            ) AS balance_rank
        FROM public.accounts AS a
        LEFT JOIN public.balance_entries AS be ON a.id = be.account_id
        WHERE a.user_id = get_user_id()
    )
    SELECT 
        ranked_balances.account_id,
        ranked_balances.account_name,
        ranked_balances.account_type,
        ranked_balances.category,
        ranked_balances.institution,
        ranked_balances.currency,
        ranked_balances.latest_balance,
        ranked_balances.latest_balance_date
    FROM ranked_balances
    WHERE ranked_balances.balance_rank = 1;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE SECURITY DEFINER;

-- Optimized Function: Timeseries Balance Calculation
CREATE OR REPLACE FUNCTION public.get_balances_for_timeseries(
    dates date[]
)
RETURNS TABLE(report_date date, account_type public.account_type, amount decimal, currency public.currency_code) AS $$
BEGIN
    RETURN QUERY WITH latest_balances AS (
        SELECT 
            d.report_date,
            a.id AS account_id,
            a.type AS account_type,
            a.currency,
            b.amount,
            ROW_NUMBER() OVER (
                PARTITION BY a.id, d.report_date 
                ORDER BY b.date DESC
            ) AS balance_rank
        FROM 
            public.accounts a
        CROSS JOIN 
            unnest(dates) AS d(report_date)
        LEFT JOIN 
            public.balance_entries b ON a.id = b.account_id AND b.date <= d.report_date
        WHERE 
            a.user_id = get_user_id()
            AND a.include_in_net_worth = TRUE
    )
    SELECT 
        report_date, 
        account_type, 
        amount, 
        currency
    FROM latest_balances
    WHERE balance_rank = 1;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_net_worth_history(
  start_date DATE,
  end_date DATE DEFAULT CURRENT_DATE,
  sampling_strategy TEXT DEFAULT 'adaptive',
  max_points INTEGER DEFAULT 100
)
RETURNS TABLE(
  date DATE,
  accounts_data JSONB
) AS $$
DECLARE
  total_days INTEGER;
BEGIN
  -- Validate inputs
  IF start_date IS NULL OR end_date IS NULL THEN
    RAISE EXCEPTION 'Both start_date and end_date are required';
  END IF;

  IF start_date > end_date THEN
    RAISE EXCEPTION 'start_date cannot be after end_date';
  END IF;

  -- Normalize parameters
  max_points := LEAST(GREATEST(max_points, 10), 500);
  sampling_strategy := LOWER(COALESCE(sampling_strategy, 'adaptive'));
  
  IF sampling_strategy NOT IN ('daily', 'weekly', 'monthly', 'adaptive') THEN
    sampling_strategy := 'adaptive';
  END IF;

  total_days := (end_date - start_date) + 1;

  RETURN QUERY
  WITH 
    -- Generate anchor dates based on strategy
    anchor_dates AS (
      -- Daily sampling
      SELECT gs::date AS anchor_date
      FROM generate_series(start_date, end_date, '1 day'::interval) AS gs
      WHERE sampling_strategy = 'daily'
      
      UNION ALL
      
      -- Weekly sampling (end of week - Sunday)
      SELECT anchor_date FROM (
        WITH first_eow AS (
          SELECT CASE
            WHEN (date_trunc('week', start_date)::date + 6) < start_date
              THEN (date_trunc('week', start_date)::date + 13)
            ELSE (date_trunc('week', start_date)::date + 6)
          END AS first_week_end
        )
        SELECT gs::date AS anchor_date
        FROM first_eow, 
             generate_series(first_week_end, end_date, '7 days') AS gs
      ) weekly_calc
      WHERE sampling_strategy = 'weekly'
      
      UNION ALL
      
      -- Monthly sampling (end of month) - FIXED
      SELECT anchor_date FROM (
        WITH month_starts AS (
          -- Generate the first day of each month in the range
          SELECT generate_series(
            date_trunc('month', start_date),
            date_trunc('month', end_date),
            '1 month'
          )::date AS month_start
        ),
        month_ends AS (
          -- Convert each month start to the actual last day of that month
          SELECT (month_start + INTERVAL '1 month - 1 day')::date AS anchor_date
          FROM month_starts
        )
        SELECT anchor_date
        FROM month_ends
        WHERE anchor_date >= start_date  -- Only include if month-end is within range
      ) monthly_calc
      WHERE sampling_strategy = 'monthly'
      
      UNION ALL
      
      -- Adaptive sampling
      SELECT gs::date AS anchor_date
      FROM generate_series(
        start_date, 
        end_date, 
        (GREATEST(1, CEIL(total_days::DECIMAL / max_points)::INT)::text || ' days')::interval
      ) AS gs
      WHERE sampling_strategy = 'adaptive'
    ),
    
    -- Always include end_date and remove duplicates
    final_dates AS (
      SELECT DISTINCT anchor_date
      FROM (
        SELECT anchor_date FROM anchor_dates
        UNION
        SELECT end_date AS anchor_date
      ) combined
      WHERE anchor_date BETWEEN start_date AND end_date
      ORDER BY anchor_date
    ),
    
    -- Apply max_points limit if needed (except for adaptive)
    limited_dates AS (
      SELECT anchor_date FROM final_dates
      WHERE sampling_strategy = 'adaptive'
      
      UNION ALL
      
      SELECT anchor_date FROM (
        WITH ordered AS (
          SELECT anchor_date,
                 ROW_NUMBER() OVER (ORDER BY anchor_date) AS rn,
                 COUNT(*) OVER () AS total
          FROM final_dates
        )
        SELECT anchor_date
        FROM ordered
        WHERE sampling_strategy != 'adaptive'
          AND (
            total <= max_points
            OR rn % CEIL(total::DECIMAL / max_points)::INT = 1
            OR anchor_date = end_date
          )
      ) limited_non_adaptive
    ),
    
    -- Get account balances for each date
    account_balances AS (
      SELECT 
        ld.anchor_date,
        jsonb_agg(
          jsonb_build_object(
            'account_id', a.id,
            'account_name', a.name,
            'account_type', a.type,
            'currency', a.currency,
            'category', a.category,
            'institution', a.institution,
            'include_in_net_worth', a.include_in_net_worth,
            'balance', COALESCE(latest_balance.amount, 0)
          ) ORDER BY a.name
        ) AS accounts_data
      FROM limited_dates ld
      CROSS JOIN public.accounts a
      LEFT JOIN LATERAL (
        SELECT be.amount
        FROM public.balance_entries be
        WHERE be.account_id = a.id
          AND be.date <= ld.anchor_date
        ORDER BY be.date DESC
        LIMIT 1
      ) latest_balance ON TRUE
      WHERE a.user_id = get_user_id()
        AND a.include_in_net_worth = TRUE
      GROUP BY ld.anchor_date
    )
  
  SELECT 
    ab.anchor_date AS date,
    ab.accounts_data
  FROM account_balances ab
  ORDER BY ab.anchor_date;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function for dynamic 'ALL' period (if you still need it)
CREATE OR REPLACE FUNCTION public.get_earliest_balance_date()
RETURNS DATE AS $$
BEGIN
  RETURN (
    SELECT COALESCE(MIN(be.date), CURRENT_DATE - INTERVAL '1 year')
    FROM public.balance_entries be
    JOIN public.accounts a ON a.id = be.account_id
    WHERE a.user_id = get_user_id()
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =============================================

-- Optional Index Incase there is performane Issue
--
-- Create an index to optimize the function's performance
-- CREATE INDEX IF NOT EXISTS idx_balance_entries_account_date 
-- ON public.balance_entries (account_id, date DESC);
--
-- Create an index to optimize the user_id filtering
-- CREATE INDEX IF NOT EXISTS idx_accounts_user_id 
-- ON public.accounts (user_id);

-- Create an index to optimize the include_in_net_worth filtering
-- CREATE INDEX IF NOT EXISTS idx_accounts_user_include 
-- ON public.accounts (user_id, include_in_net_worth) 
-- WHERE include_in_net_worth = TRUE;
