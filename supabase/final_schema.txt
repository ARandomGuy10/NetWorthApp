-- =============================================
-- NetWorthApp Database Schema - Final Version
-- amount > 0 enforced in balance_entries for clarity
-- =============================================

-- 0. Required Extensions
CREATE EXTENSION IF NOT EXISTS "pgcrypto";  -- Enables gen_random_uuid()

-- =============================================


-- 1. Custom Types
CREATE TYPE public.theme AS ENUM (
  'LIGHT', 
  'DARK', 
  'SYSTEM', 
  'MODERN_FINANCE', 
  'WARM_LUXURY', 
  'NEO_BANKING', 
  'DARK_MODE_FOCUSED', 
  'EARTHY_CALM'
);
CREATE TYPE public.account_type AS ENUM ('asset', 'liability');
CREATE TYPE public.currency_code AS ENUM (
    'AUD', 'BGN', 'BRL', 'CAD', 'CHF', 'CNY', 'CZK', 'DKK', 
    'EUR', 'GBP', 'HKD', 'HUF', 'IDR', 'ILS', 'INR', 'ISK', 
    'JPY', 'KRW', 'MXN', 'MYR', 'NOK', 'NZD', 'PHP', 'PLN', 
    'RON', 'SEK', 'SGD', 'THB', 'TRY', 'USD', 'ZAR'
);
-- =============================================

-- 2. Auth Helper Function â€“ Extract user ID from Clerk JWT
CREATE OR REPLACE FUNCTION get_user_id()
RETURNS TEXT AS $$
  SELECT nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::TEXT;
$$ LANGUAGE sql STABLE;

-- =============================================

-- 3. Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
  id TEXT PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  email TEXT UNIQUE,
  preferred_currency public.currency_code NOT NULL DEFAULT 'EUR',
  timezone VARCHAR(50) DEFAULT 'UTC',
  date_format VARCHAR(20) DEFAULT 'YYYY-MM-DD',
  last_sign_in_at timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  theme public.theme NOT NULL DEFAULT 'DARK'
);

-- =============================================

-- 4. Accounts Table
CREATE TABLE IF NOT EXISTS public.accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL CHECK (length(trim(name)) > 0),
  type public.account_type NOT NULL,
  currency public.currency_code NOT NULL DEFAULT 'EUR',
  category TEXT NOT NULL,
  institution TEXT DEFAULT '',
  include_in_net_worth BOOLEAN DEFAULT TRUE,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- =============================================

-- 5. Balance Entries Table (amount > 0)
CREATE TABLE IF NOT EXISTS public.balance_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID REFERENCES public.accounts(id) ON DELETE CASCADE NOT NULL,
  amount DECIMAL(15,2) NOT NULL CHECK (amount > 0),
  date DATE NOT NULL,
  notes TEXT DEFAULT '',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE (account_id, date)
);

-- =============================================

-- 6. Exchange Rates Table
CREATE TABLE IF NOT EXISTS public.exchange_rates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  from_currency public.currency_code NOT NULL,
  to_currency public.currency_code NOT NULL,
  rate DECIMAL(15,8) NOT NULL CHECK (rate > 0),
  date DATE NOT NULL,
  source VARCHAR(50) DEFAULT 'manual',
  created_at timestamptz DEFAULT now(),
  CHECK (from_currency <> to_currency),
  UNIQUE (from_currency, to_currency, date)
);

-- =============================================

-- 7. Enable Row-Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.balance_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exchange_rates ENABLE ROW LEVEL SECURITY;

-- =============================================

-- 8. RLS Policies

-- Profiles
CREATE POLICY "Users can view their own profile" 
  ON public.profiles FOR SELECT TO authenticated
  USING (id = get_user_id());

CREATE POLICY "Users can insert their own profile" 
  ON public.profiles FOR INSERT TO authenticated
  WITH CHECK (id = get_user_id());

CREATE POLICY "Users can update their own profile" 
  ON public.profiles FOR UPDATE TO authenticated
  USING (id = get_user_id());

CREATE POLICY "Users can delete their own profile" 
  ON public.profiles FOR DELETE TO authenticated
  USING (id = get_user_id());

-- Accounts
CREATE POLICY "Users can read their own accounts"
  ON public.accounts FOR SELECT TO authenticated
  USING (user_id = get_user_id());

CREATE POLICY "Users can insert their own accounts"
  ON public.accounts FOR INSERT TO authenticated
  WITH CHECK (user_id = get_user_id());

CREATE POLICY "Users can update their own accounts"
  ON public.accounts FOR UPDATE TO authenticated
  USING (user_id = get_user_id());

CREATE POLICY "Users can delete their own accounts"
  ON public.accounts FOR DELETE TO authenticated
  USING (user_id = get_user_id());

-- Balance Entries
CREATE POLICY "Users can read own balance entries"
  ON public.balance_entries FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can insert own balance entries"
  ON public.balance_entries FOR INSERT TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can update own balance entries"
  ON public.balance_entries FOR UPDATE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

CREATE POLICY "Users can delete own balance entries"
  ON public.balance_entries FOR DELETE TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.accounts 
      WHERE accounts.id = balance_entries.account_id 
      AND accounts.user_id = get_user_id()
    )
  );

-- Exchange Rates
CREATE POLICY "Authenticated users can read exchange rates"
  ON public.exchange_rates FOR SELECT TO authenticated
  USING (true);

-- =============================================

-- 9. Timestamp Trigger Function
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =============================================

-- 10. Triggers to update updated_at on update
CREATE TRIGGER trg_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER trg_accounts_updated_at
  BEFORE UPDATE ON public.accounts
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER trg_balance_entries_updated_at
  BEFORE UPDATE ON public.balance_entries
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- =============================================

-- 11.  Improved accounts with balances function
-- Function to get accounts balances for the current authenticated user
CREATE OR REPLACE FUNCTION public.get_accounts_with_balances(
)
RETURNS TABLE(
    account_id uuid,
    account_name text,
    account_type public.account_type,
    category text,
    institution text,
    currency public.currency_code,
    latest_balance decimal,
    latest_balance_date date
) AS $$
BEGIN
    RETURN QUERY
    WITH ranked_balances AS (
        SELECT 
            a.id AS account_id,
            a.name AS account_name,
            a.type AS account_type,
            a.category,
            a.institution,
            a.currency,
            be.amount AS latest_balance,
            be.date AS latest_balance_date,
            ROW_NUMBER() OVER (
                PARTITION BY a.id 
                ORDER BY be.date DESC NULLS LAST
            ) AS balance_rank
        FROM public.accounts AS a
        LEFT JOIN public.balance_entries AS be ON a.id = be.account_id
        WHERE a.user_id = get_user_id()
    )
    SELECT 
        ranked_balances.account_id,
        ranked_balances.account_name,
        ranked_balances.account_type,
        ranked_balances.category,
        ranked_balances.institution,
        ranked_balances.currency,
        ranked_balances.latest_balance,
        ranked_balances.latest_balance_date
    FROM ranked_balances
    WHERE ranked_balances.balance_rank = 1;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE SECURITY DEFINER;

-- Optimized Function: Timeseries Balance Calculation
CREATE OR REPLACE FUNCTION public.get_balances_for_timeseries(
    dates date[]
)
RETURNS TABLE(report_date date, account_type public.account_type, amount decimal, currency public.currency_code) AS $$
BEGIN
    RETURN QUERY WITH latest_balances AS (
        SELECT 
            d.report_date,
            a.id AS account_id,
            a.type AS account_type,
            a.currency,
            b.amount,
            ROW_NUMBER() OVER (
                PARTITION BY a.id, d.report_date 
                ORDER BY b.date DESC
            ) AS balance_rank
        FROM 
            public.accounts a
        CROSS JOIN 
            unnest(dates) AS d(report_date)
        LEFT JOIN 
            public.balance_entries b ON a.id = b.account_id AND b.date <= d.report_date
        WHERE 
            a.user_id = get_user_id()
            AND a.include_in_net_worth = TRUE
    )
    SELECT 
        report_date, 
        account_type, 
        amount, 
        currency
    FROM latest_balances
    WHERE balance_rank = 1;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- =============================================

-- Optional Index Incase there is performane Issue
--
-- Create an index to optimize the function's performance
-- CREATE INDEX IF NOT EXISTS idx_balance_entries_account_date 
-- ON public.balance_entries (account_id, date DESC);
--
-- Create an index to optimize the user_id filtering
-- CREATE INDEX IF NOT EXISTS idx_accounts_user_id 
-- ON public.accounts (user_id);