import { createClient } from 'jsr:@supabase/supabase-js@^2';

interface AccountData {
  account_id: string;
  account_name: string;
  account_type: 'asset' | 'liability';
  category: string;
  institution: string;
  currency: string;
  include_in_net_worth: boolean;
  is_archived: boolean;
  latest_balance: number | null;
  latest_balance_date: string;
}

// Enhanced error handling
class ApiError extends Error {
  status;
  constructor(status, message){
    super(message);
    this.status = status;
    this.name = 'ApiError';
  }
}
// Utility functions with improved error handling
function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-store, max-age=0'
    }
  });
}
// Currency conversion via Frankfurter API
async function getLiveRates(fromCurrencies, toCurrency, retries = 2) {
  const fromSymbols = fromCurrencies.filter((c)=>c !== toCurrency);
  if (fromSymbols.length === 0) return {};
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(()=>controller.abort(), 5000);
    const apiUrl = `https://api.frankfurter.app/latest?from=${toCurrency}&to=${fromSymbols.join(',')}`;
    const response = await fetch(apiUrl, {
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) throw new Error('Failed to fetch exchange rates');
    const data = await response.json();
    const invertedRates = {};
    for (const [currency, rate] of Object.entries(data.rates)){
      invertedRates[currency] = 1 / rate;
    }
    return invertedRates;
  } catch (error) {
    if (retries > 0) {
      console.warn(`Rate fetch failed, retrying. Attempts left: ${retries}`);
      return getLiveRates(fromCurrencies, toCurrency, retries - 1);
    }
    throw new ApiError(500, 'Could not fetch exchange rates');
  }
}
// Main handler with enhanced error handling
Deno.serve(async (req)=>{
  try {
    // Strict method and content-type validation
    if (req.method !== 'POST') throw new ApiError(405, 'Method Not Allowed');
    if (req.headers.get('content-type') !== 'application/json') throw new ApiError(415, 'Invalid Content-Type');
    const supabaseClient = createClient(Deno.env.get('SUPABASE_URL') ?? '', Deno.env.get('SUPABASE_ANON_KEY') ?? '', {
      global: {
        headers: {
          Authorization: req.headers.get('Authorization') ?? ''
        }
      }
    });

    // Parse request body
    const { toCurrency } = await req.json();


    const { data: accounts, error } = await supabaseClient.rpc('get_accounts_with_balances');

    if (error) throw new ApiError(500, `Supabase RPC error: ${error.message}`);
    if (!accounts || accounts.length === 0) {
      return jsonResponse({
        accounts: [],
        totalNetWorth: 0,
        totalAssets: 0,
        totalLiabilities: 0
      });
    }
    const uniqueCurrencies = [
      ...new Set(accounts.map((a)=>a.currency).filter((c)=>c && c !== toCurrency))
    ];
    const rates = await getLiveRates(uniqueCurrencies, toCurrency);
    let totalNetWorth = 0;
    let totalAssets = 0;
    let totalLiabilities = 0;

    const accountsWithConvertedBalance = accounts.map((account: AccountData)=>{
      if (account.latest_balance === null) {
        return {
          ...account,
          converted_balance: 0
        };
      }
      const rate = account.currency === toCurrency ? 1 : rates[account.currency] || 1;
      const converted_balance = account.latest_balance * rate;

      if (account?.include_in_net_worth && !account?.is_archived) {
        if (account.account_type === 'asset') {
          totalNetWorth += converted_balance;
          totalAssets += converted_balance;
        } else {
          totalNetWorth -= converted_balance;
          totalLiabilities += converted_balance;
        }
      }
      return {
        ...account,
        converted_balance
      };
    });

    return jsonResponse({
      accounts: accountsWithConvertedBalance,
      totalNetWorth,
      totalAssets,
      totalLiabilities
    });
  } catch (error) {
   // Centralized error handling with extensive logging
    console.error('[Edge Function Error]', JSON.stringify({
      name: error.name,
      message: error.message,
      stack: error.stack,
      status: error instanceof ApiError ? error.status : 500
    }));
    // Return error response
    return jsonResponse({
      error: error.message || 'Unexpected server error',
      details: error instanceof Error ? error.stack : undefined
    }, error instanceof ApiError ? error.status : 500);
  }
});
